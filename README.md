# Go Exercises
### some tasks from an internship at Wildberries for practice language
### 1.Какой самый эффективный способ конкатенации строк?  
Ответ: strings.Builder. При вызове метода String() не происходит повторного выделения памяти и копирования.  
Пример:
```
var builder strings.Builder   
builder.Grow(len(i) + len(j))// память аллоцируется только на этом моменте
builder.WriteString(i)
builder.WriteString(j)
return builder.String()
```
### 2. Что такое интерфейсы, как они применяются в Go?  
Интерфейс – это определение, определяющее и описывающее методы, которыми должен обладать другой тип.  
При объявлении интерфейсного типа (переменной, параметра функции или поля структуры) можно использовать любой тип данных, удовлетворяющий данному  интерфейсу. 
Это позволяет вместо конкретных реализаций опираться на более высокие абстракции.  
Их использование позволяет уменьшить связность кода, улучшить масштабирование, облегчить использование заглушек при модульном тестировании. 

### 3. Чем отличаются RWMutex от Mutex?
Ответ: RWMutex дает несколько больше контроля над памятью.  
RWMutex обладает методами RLock() и RUnlock(). При выполнении Rlock() блокируется Lock(), но Rlock() не блокируется при этом, если заблокировать Lock() то блокируется и Rlock(). Сам Rlock() не блокируется для себя. Используется, когда к объект нельзя параллельно писать, но можно параллельно читать (читателям не нужно ждать друг друга), тем самым помогает увеличить производительность.  

### 4. Чем отличаются буферизированные и не буферизированные каналы?



### 5. Какой размер у структуры struct{}{}?
Ответ: 0


### 6. Есть ли в Go перегрузка методов или операторов?
Ответ:  нет, операторы работают строго и выполняют операции только с определенными типами данных аргументов.  

### 7. В какой последовательности будут выведены элементы map[int]int?  

Пример:
```
m[0]=1
m[1]=124
m[2]=281
```

Ответ: Если выводить через fmt.Print то порядок будет по значению ключа, при выводе через цикл for _, _ := range{} m не гарантирует упорядоченный обход элементов, он может меняться от запуска к запуску программы

### 8. В чем разница make и new?
Ответ: make - инициализирует объект new - аллоцирует память в куче, но не инициализирует

### 9. Сколько существует способов задать переменную типа slice или map?
Ответ: 3 способа: make, new и литералы.

### 10. Что выведет данная программа и почему?
```
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
Ответ: в данном случае в  update(p *int) изменяется копия указателя, а не переменная, находящаяся по исходному адресу. В функции main ни p, ни a не изменится.

### 11. Что выведет данная программа и почему?
```
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
Ответ: выведет числа от 0 до 4 (возможно не по порядку), далее deadlock; wg sync.WaitGroup следует передавать по указателю. В данном случае wg.Done() был исполнен локально над копией и wg.Wait() все еще ждет окончание работы 5 горутин.
### 12. Что выведет данная программа и почему?
```
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
Ответ: 0  
Объявляется другая переменная n с более узкой областью видимости в пределах тела if{}, которая перекрывает внешнюю n.
### 13. Что выведет данная программа и почему?
```
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
Ответ: [100 2 3 4 5]  
В функцию передали копию слайса (структуры), в котором лежит указатель на исходный базовый массив и его можно изменить, поэтому первый элемент изменится. Далее вызов append реалоцирует память и структуре v хранится указатель уже на новый массив, поэтому все изменения в нем не затронут оригинальный слайс
### 14. Что выведет данная программа и почему?
```
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
Ответ: append возвращает новый слайс и последующие изменения элементов уже производятся в нем, тогда как в main лежит исходный
